sel <- lab[,] == 0
lab[sel] <- rgb(1, 1, 1)
sel <- lab[,] == -2
lab[sel] <- rgb(1, 0, 0)
sel <- lab[,] == -3
lab[sel] <- rgb(1, 1, 0)
sel <- lab[,] == -4
lab[sel] <- rgb(0, 0, 1)
sel <- lab[,] == -5
lab[sel] <- rgb(0, 1, 0)
sel <- lab[,] == 1
lab[sel] <- rgb(0.3, 0.3, 0.3)
sel <- lab[,] == 2
lab[sel] <- rgb(0.4, 0.4, 0.4)
sel <- lab[,] == 3
lab[sel] <- rgb(0.6, 0.6, 0.6)
sel <- lab[,] == 4
lab[sel] <- rgb(0.8, 0.8, 0.8)
grid.newpage()
grid.raster(lab, interpolate=F)
}
mainA <- function(data,currentPosition){
pathFound=FALSE
Sys.sleep(0.01)
rowNum=c(1,.Machine$integer.max)
if (is.vector(currentPosition)) currentPosition=matrix(currentPosition,ncol=3)
for(i in 1:nrow(currentPosition)){
dol=data[currentPosition[i,1]+1,currentPosition[i,2]]
desno=data[currentPosition[i,1],currentPosition[i,2]+1]
gor=data[currentPosition[i,1]-1,currentPosition[i,2]]
levo=data[currentPosition[i,1],currentPosition[i,2]-1]
x=c(dol,desno,gor,levo)
smer=which.max(1 / x)
rez=currentPosition[i,3]+x[smer]
if (any(-3 == x)){
rowNum[1]=i
rowNum[2]=rez
break
}
if (rowNum[2] > rez){
rowNum[1]=i
rowNum[2]=rez
}
}
i=rowNum[1]
data[currentPosition[i,1],currentPosition[i,2]]=-4
screen <- plotLabyrinth(data)
dol=data[currentPosition[i,1]+1,currentPosition[i,2]]
desno=data[currentPosition[i,1],currentPosition[i,2]+1]
gor=data[currentPosition[i,1]-1,currentPosition[i,2]]
levo=data[currentPosition[i,1],currentPosition[i,2]-1]
x=c(dol,desno,gor,levo)
smer=which.max(1 / x)
if (any(x==-3))
data[currentPosition[i,1],currentPosition[i,2]]=-5
nextPosition=c()
if (dol == -3) return(data)
if (dol >= 0){
if (smer==1){
nextPosition[length(nextPosition)+1]=currentPosition[i,1]+1
nextPosition[length(nextPosition)+1]=currentPosition[i,2]
nextPosition[length(nextPosition)+1]=currentPosition[i,3]+dol
data[currentPosition[i,1]+1,currentPosition[i,2]] = -2
screen <- plotLabyrinth(data)
}
else{
nextPosition[length(nextPosition)+1]=currentPosition[i,1]+1
nextPosition[length(nextPosition)+1]=currentPosition[i,2]
nextPosition[length(nextPosition)+1]=currentPosition[i,3]
data[currentPosition[i,1]+1,currentPosition[i,2]] = -2
screen <- plotLabyrinth(data)
}
}
if (desno == -3) return(data)
if (desno >= 0){
if (smer==2){
nextPosition[length(nextPosition)+1]=currentPosition[i,1]
nextPosition[length(nextPosition)+1]=currentPosition[i,2]+1
nextPosition[length(nextPosition)+1]=currentPosition[i,3]+desno
data[currentPosition[i,1],currentPosition[i,2]+1] = -2
screen <- plotLabyrinth(data)
}
else{
nextPosition[length(nextPosition)+1]=currentPosition[i,1]
nextPosition[length(nextPosition)+1]=currentPosition[i,2]+1
nextPosition[length(nextPosition)+1]=currentPosition[i,3]
data[currentPosition[i,1],currentPosition[i,2]+1] = -2
screen <- plotLabyrinth(data)
}
}
if (gor == -3) return(data)
if (gor >= 0){
if (smer==3){
nextPosition[length(nextPosition)+1]=currentPosition[i,1]-1
nextPosition[length(nextPosition)+1]=currentPosition[i,2]
nextPosition[length(nextPosition)+1]=currentPosition[i,3]+gor
data[currentPosition[i,1]-1,currentPosition[i,2]] = -2
screen <- plotLabyrinth(data)
}
else{
nextPosition[length(nextPosition)+1]=currentPosition[i,1]-1
nextPosition[length(nextPosition)+1]=currentPosition[i,2]
nextPosition[length(nextPosition)+1]=currentPosition[i,3]
data[currentPosition[i,1]-1,currentPosition[i,2]] = -2
screen <- plotLabyrinth(data)
}
}
if (levo == -3) return(data)
if (levo >= 0){
if (smer==4){
nextPosition[length(nextPosition)+1]=currentPosition[i,1]
nextPosition[length(nextPosition)+1]=currentPosition[i,2]-1
nextPosition[length(nextPosition)+1]=currentPosition[i,3]+levo
data[currentPosition[i,1],currentPosition[i,2]-1] = -2
screen <- plotLabyrinth(data)
}
else{
nextPosition[length(nextPosition)+1]=currentPosition[i,1]
nextPosition[length(nextPosition)+1]=currentPosition[i,2]-1
nextPosition[length(nextPosition)+1]=currentPosition[i,3]
data[currentPosition[i,1],currentPosition[i,2]-1] = -2
screen <- plotLabyrinth(data)
}
}
if (nrow(currentPosition) > 1 ){
nextPosMx=currentPosition[-i,]
if (length(nextPosition) > 0)
nextPosMx=rbind(nextPosMx,t(matrix(c(nextPosition), nrow=3)))
}else{
if (length(nextPosition) > 0)
nextPosMx=t(matrix(c(nextPosition), nrow=3))
else
return(data)
}
if (!pathFound)
kt=mainA(data,nextPosMx)
if (is.matrix(kt)) data=kt
if (smer == 1 && data[currentPosition[i,1]+1,currentPosition[i,2]] == -5 ||
smer == 2 && data[currentPosition[i,1],currentPosition[i,2]+1] == -5 ||
smer == 3 && data[currentPosition[i,1]-1,currentPosition[i,2]] == -5 ||
smer == 4 && data[currentPosition[i,1],currentPosition[i,2]-1] == -5)
data[currentPosition[i,1],currentPosition[i,2]]=-5
else if(data[currentPosition[i,1]+1,currentPosition[i,2]] == -5 ||
data[currentPosition[i,1],currentPosition[i,2]+1] == -5 ||
data[currentPosition[i,1]-1,currentPosition[i,2]] == -5 ||
data[currentPosition[i,1],currentPosition[i,2]-1] == -5)
data[currentPosition[i,1],currentPosition[i,2]]=-5
screen <- plotLabyrinth(data)
return(data)
}
getPath<- function(data,cp){
pathData=cp
dol=data[cp[1]+1,cp[2]]
desno=data[cp[1],cp[2]+1]
gor=data[cp[1]-1,cp[2]]
levo=data[cp[1],cp[2]-1]
x=c(dol,desno,gor,levo)
if(dol == -5)
cp[1]=cp[1]+1
else if(desno == -5)
cp[2]=cp[2]+1
else if(gor == -5)
cp[1]=cp[1]-1
else if(levo == -5)
cp[2]=cp[2]-1
if (!any(x==-5)){
data[pathData[1],pathData[2]]=-4
if(dol == -3)
cp[1]=cp[1]+1
else if(desno == -3)
cp[2]=cp[2]+1
else if(gor == -3)
cp[1]=cp[1]-1
else if(levo == -3)
cp[2]=cp[2]-1
return(rbind(pathData,cp))
}
data[pathData[1],pathData[2]]=-4
return(rbind(pathData,getPath(data,cp)))
}
getPoints<- function(data,matrix){
points=0
for(i in 1:nrow(matrix)){
points=points+data[matrix[i,1],matrix[i,2]]
}
return(points)
}
Azvezda<- function(data,currPos){
data=mainA( data,matrix( c(currPos,0), ncol=3 ) )
return(getPath(data,currPos))
}
data <- read.table("labyrinth_6.txt", sep=",", header=F)
data <- as.matrix(data)
screen <- plotLabyrinth(data)
a=Azvezda(data,which(data == -2, TRUE))
getPoints(data,a)
source("bfs.R")
###############################################################################
#                               SOURCE                                        #
###############################################################################
source("dfs.R")
source("bfs.R")
source("izris.R")
source("modifyM.R")
###############################################################################
#                        PRIPRAVIMO PODATKE                                   #
###############################################################################
data <- read.table("labyrinth_2.txt", sep=",", header=F)
data <- as.matrix(data)
#preimenujemo zaradi lažjega branja
data <- rename(data)
#določimo stolpec in vrstico starta
start <- startPosition(data)
#določimo številko štartnega kvadratka
trueStart = toString(nrow(data) * (start[1,1] - 1) + start[1,2])
#ponovimo še za finish
finish <- finishPosition(data)
#le da naredimo vektor, saj je ciljev več
trueFinish = c()
for (var in 1:nrow(finish)) {
trueFinish <- c(trueFinish, toString(nrow(data) * (finish[var,1] - 1) + finish[var,2]))
}
screen <- plotLabyrinth(data)
#naredimo matriko sosedov
sosedje <- matrikaSosedov(data)
#preimenujemo stolpce in vrstice v številke kvadratkov
#colnames(sosedje) <- c(1:nrow(sosedje))
#rownames(sosedje) <- c(1:ncol(sosedje))
sosedje <- rename(sosedje)
#naredimo bfs
list(pot,bfs) <- breadth.first(sosedje, trueStart, trueFinish, data)
install.packages("gsubfn")
library("gsubfn")
#naredimo bfs
list(pot,bfs) <- breadth.first(sosedje, trueStart, trueFinish, data)
###############################################################################
#                               SOURCE                                        #
###############################################################################
source("dfs.R")
source("bfs.R")
source("izris.R")
source("modifyM.R")
#install.packages("gsubfn")
library("gsubfn")
###############################################################################
#                        PRIPRAVIMO PODATKE                                   #
###############################################################################
data <- read.table("labyrinth_2.txt", sep=",", header=F)
data <- as.matrix(data)
#preimenujemo zaradi lažjega branja
data <- rename(data)
#določimo stolpec in vrstico starta
start <- startPosition(data)
#določimo številko štartnega kvadratka
trueStart = toString(nrow(data) * (start[1,1] - 1) + start[1,2])
#ponovimo še za finish
finish <- finishPosition(data)
#le da naredimo vektor, saj je ciljev več
trueFinish = c()
for (var in 1:nrow(finish)) {
trueFinish <- c(trueFinish, toString(nrow(data) * (finish[var,1] - 1) + finish[var,2]))
}
screen <- plotLabyrinth(data)
#naredimo matriko sosedov
sosedje <- matrikaSosedov(data)
#preimenujemo stolpce in vrstice v številke kvadratkov
#colnames(sosedje) <- c(1:nrow(sosedje))
#rownames(sosedje) <- c(1:ncol(sosedje))
sosedje <- rename(sosedje)
#naredimo bfs
list[pot,bfs] <- breadth.first(sosedje, trueStart, trueFinish, data)
pot
bfs
g <- convertCoord(bfs, ncol(sosedje))
g
source('~/GitHub/Path_algorithms/izris.R')
###############################################################################
#                               SOURCE                                        #
###############################################################################
source("dfs.R")
source("bfs.R")
source("izris.R")
source("modifyM.R")
#install.packages("gsubfn")
library("gsubfn")
###############################################################################
#                        PRIPRAVIMO PODATKE                                   #
###############################################################################
data <- read.table("labyrinth_2.txt", sep=",", header=F)
data <- as.matrix(data)
#preimenujemo zaradi lažjega branja
data <- rename(data)
#določimo stolpec in vrstico starta
start <- startPosition(data)
#določimo številko štartnega kvadratka
trueStart = toString(nrow(data) * (start[1,1] - 1) + start[1,2])
#ponovimo še za finish
finish <- finishPosition(data)
#le da naredimo vektor, saj je ciljev več
trueFinish = c()
for (var in 1:nrow(finish)) {
trueFinish <- c(trueFinish, toString(nrow(data) * (finish[var,1] - 1) + finish[var,2]))
}
screen <- plotLabyrinth(data)
#naredimo matriko sosedov
sosedje <- matrikaSosedov(data)
#preimenujemo stolpce in vrstice v številke kvadratkov
#colnames(sosedje) <- c(1:nrow(sosedje))
#rownames(sosedje) <- c(1:ncol(sosedje))
sosedje <- rename(sosedje)
#naredimo bfs
list[pot,bfs] <- breadth.first(sosedje, trueStart, trueFinish, data)
g <- convertCoord(bfs, ncol(sosedje))
plotLabyrinth(pathMatrixes(pot,g))
###############################################################################
#                               SOURCE                                        #
###############################################################################
source("dfs.R")
source("bfs.R")
source("izris.R")
source("modifyM.R")
#install.packages("gsubfn")
library("gsubfn")
###############################################################################
#                        PRIPRAVIMO PODATKE                                   #
###############################################################################
data <- read.table("labyrinth_2.txt", sep=",", header=F)
data <- as.matrix(data)
#preimenujemo zaradi lažjega branja
data <- rename(data)
#določimo stolpec in vrstico starta
start <- startPosition(data)
#določimo številko štartnega kvadratka
trueStart = toString(nrow(data) * (start[1,1] - 1) + start[1,2])
#ponovimo še za finish
finish <- finishPosition(data)
#le da naredimo vektor, saj je ciljev več
trueFinish = c()
for (var in 1:nrow(finish)) {
trueFinish <- c(trueFinish, toString(nrow(data) * (finish[var,1] - 1) + finish[var,2]))
}
screen <- plotLabyrinth(data)
#naredimo matriko sosedov
sosedje <- matrikaSosedov(data)
#preimenujemo stolpce in vrstice v številke kvadratkov
#colnames(sosedje) <- c(1:nrow(sosedje))
#rownames(sosedje) <- c(1:ncol(sosedje))
sosedje <- rename(sosedje)
#naredimo bfs
list[pot,bfs] <- breadth.first(sosedje, trueStart, trueFinish, data)
g <- convertCoord(bfs, ncol(sosedje))
pathMatrixes(pot,g)
###############################################################################
#                               SOURCE                                        #
###############################################################################
source("dfs.R")
source("bfs.R")
source("izris.R")
source("modifyM.R")
#install.packages("gsubfn")
library("gsubfn")
###############################################################################
#                        PRIPRAVIMO PODATKE                                   #
###############################################################################
data <- read.table("labyrinth_2.txt", sep=",", header=F)
data <- as.matrix(data)
#preimenujemo zaradi lažjega branja
data <- rename(data)
#določimo stolpec in vrstico starta
start <- startPosition(data)
#določimo številko štartnega kvadratka
trueStart = toString(nrow(data) * (start[1,1] - 1) + start[1,2])
#ponovimo še za finish
finish <- finishPosition(data)
#le da naredimo vektor, saj je ciljev več
trueFinish = c()
for (var in 1:nrow(finish)) {
trueFinish <- c(trueFinish, toString(nrow(data) * (finish[var,1] - 1) + finish[var,2]))
}
screen <- plotLabyrinth(data)
#naredimo matriko sosedov
sosedje <- matrikaSosedov(data)
#preimenujemo stolpce in vrstice v številke kvadratkov
#colnames(sosedje) <- c(1:nrow(sosedje))
#rownames(sosedje) <- c(1:ncol(sosedje))
sosedje <- rename(sosedje)
#naredimo bfs
list[pot,bfs] <- breadth.first(sosedje, trueStart, trueFinish, data)
g <- convertCoord(bfs, ncol(sosedje))
pathMatrixes(pot,g)
g
###############################################################################
#                               SOURCE                                        #
###############################################################################
source("dfs.R")
source("bfs.R")
source("izris.R")
source("modifyM.R")
#install.packages("gsubfn")
library("gsubfn")
###############################################################################
#                        PRIPRAVIMO PODATKE                                   #
###############################################################################
data <- read.table("labyrinth_2.txt", sep=",", header=F)
data <- as.matrix(data)
#preimenujemo zaradi lažjega branja
data <- rename(data)
#določimo stolpec in vrstico starta
start <- startPosition(data)
#določimo številko štartnega kvadratka
trueStart = toString(nrow(data) * (start[1,1] - 1) + start[1,2])
#ponovimo še za finish
finish <- finishPosition(data)
#le da naredimo vektor, saj je ciljev več
trueFinish = c()
for (var in 1:nrow(finish)) {
trueFinish <- c(trueFinish, toString(nrow(data) * (finish[var,1] - 1) + finish[var,2]))
}
screen <- plotLabyrinth(data)
#naredimo matriko sosedov
sosedje <- matrikaSosedov(data)
#preimenujemo stolpce in vrstice v številke kvadratkov
#colnames(sosedje) <- c(1:nrow(sosedje))
#rownames(sosedje) <- c(1:ncol(sosedje))
sosedje <- rename(sosedje)
#naredimo bfs
list[pot,bfs] <- breadth.first(sosedje, trueStart, trueFinish, data)
g <- convertCoord(bfs, ncol(sosedje))
pathMatrixes(pot,g)
#naredimo dfs
dfs <- depth.first(sosedje, trueStart, trueFinish, data)
#izpišemo rešitev
setsOfCoords(f)
f <- convertCoord(dfs, ncol(sosedje))
#izpišemo rešitev
setsOfCoords(f)
pathMatrixesB(pot, f)
pathMatrixes(pot, f)
debugSource('~/GitHub/Path_algorithms/dfs.R', encoding = 'UTF-8')
###############################################################################
#                               SOURCE                                        #
###############################################################################
source("dfs.R")
source("bfs.R")
source("izris.R")
source("modifyM.R")
#install.packages("gsubfn")
library("gsubfn")
###############################################################################
#                        PRIPRAVIMO PODATKE                                   #
###############################################################################
data <- read.table("labyrinth_2.txt", sep=",", header=F)
data <- as.matrix(data)
#preimenujemo zaradi lažjega branja
data <- rename(data)
#določimo stolpec in vrstico starta
start <- startPosition(data)
#določimo številko štartnega kvadratka
trueStart = toString(nrow(data) * (start[1,1] - 1) + start[1,2])
#ponovimo še za finish
finish <- finishPosition(data)
#le da naredimo vektor, saj je ciljev več
trueFinish = c()
for (var in 1:nrow(finish)) {
trueFinish <- c(trueFinish, toString(nrow(data) * (finish[var,1] - 1) + finish[var,2]))
}
screen <- plotLabyrinth(data)
#naredimo matriko sosedov
sosedje <- matrikaSosedov(data)
#preimenujemo stolpce in vrstice v številke kvadratkov
#colnames(sosedje) <- c(1:nrow(sosedje))
#rownames(sosedje) <- c(1:ncol(sosedje))
sosedje <- rename(sosedje)
###############################################################################
#                                 DFS                                         #
###############################################################################
#naredimo dfs
list[pot,dfs] <- depth.first(sosedje, trueStart, trueFinish, data)
f <- convertCoord(dfs, ncol(sosedje))
pathMatrixes(pot, f)
#izpišemo rešitev
setsOfCoords(f)
#naredimo bfs
list[pot,bfs] <- breadth.first(sosedje, trueStart, trueFinish, data)
g <- convertCoord(bfs, ncol(sosedje))
pathMatrixes(pot,g)
#izpišemo rešitev
setsOfCoords(g)
# #naredimo novo matriko z potjo
# #naredimo novo matriko z potjo
# pathM <- pathMatrix(bfs, ncol(data), nrow(data))
# #naredimo novo matriko z potjo
# pathM <- pathMatrix(bfs, ncol(data), nrow(data))
#
# #naredimo novo matriko z potjo
# pathM <- pathMatrix(bfs, ncol(data), nrow(data))
#
# #zdržimo še podatke splepih poti, starta in finisha
# #naredimo novo matriko z potjo
# pathM <- pathMatrix(bfs, ncol(data), nrow(data))
#
# #zdržimo še podatke splepih poti, starta in finisha
# pathM <- joinMatrixes(data, pathM)
# #naredimo novo matriko z potjo
# pathM <- pathMatrix(bfs, ncol(data), nrow(data))
#
# #zdržimo še podatke splepih poti, starta in finisha
# pathM <- joinMatrixes(data, pathM)
#
source("bfs.R")
#naredimo bfs
list[pot,bfs] <- breadth.first(sosedje, trueStart, trueFinish, data)

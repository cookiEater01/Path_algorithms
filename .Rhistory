grid.raster(lab, interpolate=F)
}
mainA <- function(data,currentPosition){
pathFound=FALSE
Sys.sleep(0.01)
rowNum=c(1,.Machine$integer.max)
if (is.vector(currentPosition)) currentPosition=matrix(currentPosition,ncol=3)
for(i in 1:nrow(currentPosition)){
dol=data[currentPosition[i,1]+1,currentPosition[i,2]]
desno=data[currentPosition[i,1],currentPosition[i,2]+1]
gor=data[currentPosition[i,1]-1,currentPosition[i,2]]
levo=data[currentPosition[i,1],currentPosition[i,2]-1]
x=c(dol,desno,gor,levo)
smer=which.max(1 / x)
rez=currentPosition[i,3]+x[smer]
if (any(-3 == x)){
rowNum[1]=i
rowNum[2]=rez
break
}
if (rowNum[2] > rez){
rowNum[1]=i
rowNum[2]=rez
}
}
i=rowNum[1]
data[currentPosition[i,1],currentPosition[i,2]]=-4
screen <- plotLabyrinth(data)
dol=data[currentPosition[i,1]+1,currentPosition[i,2]]
desno=data[currentPosition[i,1],currentPosition[i,2]+1]
gor=data[currentPosition[i,1]-1,currentPosition[i,2]]
levo=data[currentPosition[i,1],currentPosition[i,2]-1]
x=c(dol,desno,gor,levo)
smer=which.max(1 / x)
if (any(x==-3))
data[currentPosition[i,1],currentPosition[i,2]]=-5
nextPosition=c()
if (dol == -3) return(data)
if (dol >= 0){
if (smer==1){
nextPosition[length(nextPosition)+1]=currentPosition[i,1]+1
nextPosition[length(nextPosition)+1]=currentPosition[i,2]
nextPosition[length(nextPosition)+1]=currentPosition[i,3]+dol
data[currentPosition[i,1]+1,currentPosition[i,2]] = -2
screen <- plotLabyrinth(data)
}
else{
nextPosition[length(nextPosition)+1]=currentPosition[i,1]+1
nextPosition[length(nextPosition)+1]=currentPosition[i,2]
nextPosition[length(nextPosition)+1]=currentPosition[i,3]
data[currentPosition[i,1]+1,currentPosition[i,2]] = -2
screen <- plotLabyrinth(data)
}
}
if (desno == -3) return(data)
if (desno >= 0){
if (smer==2){
nextPosition[length(nextPosition)+1]=currentPosition[i,1]
nextPosition[length(nextPosition)+1]=currentPosition[i,2]+1
nextPosition[length(nextPosition)+1]=currentPosition[i,3]+desno
data[currentPosition[i,1],currentPosition[i,2]+1] = -2
screen <- plotLabyrinth(data)
}
else{
nextPosition[length(nextPosition)+1]=currentPosition[i,1]
nextPosition[length(nextPosition)+1]=currentPosition[i,2]+1
nextPosition[length(nextPosition)+1]=currentPosition[i,3]
data[currentPosition[i,1],currentPosition[i,2]+1] = -2
screen <- plotLabyrinth(data)
}
}
if (gor == -3) return(data)
if (gor >= 0){
if (smer==3){
nextPosition[length(nextPosition)+1]=currentPosition[i,1]-1
nextPosition[length(nextPosition)+1]=currentPosition[i,2]
nextPosition[length(nextPosition)+1]=currentPosition[i,3]+gor
data[currentPosition[i,1]-1,currentPosition[i,2]] = -2
screen <- plotLabyrinth(data)
}
else{
nextPosition[length(nextPosition)+1]=currentPosition[i,1]-1
nextPosition[length(nextPosition)+1]=currentPosition[i,2]
nextPosition[length(nextPosition)+1]=currentPosition[i,3]
data[currentPosition[i,1]-1,currentPosition[i,2]] = -2
screen <- plotLabyrinth(data)
}
}
if (levo == -3) return(data)
if (levo >= 0){
if (smer==4){
nextPosition[length(nextPosition)+1]=currentPosition[i,1]
nextPosition[length(nextPosition)+1]=currentPosition[i,2]-1
nextPosition[length(nextPosition)+1]=currentPosition[i,3]+levo
data[currentPosition[i,1],currentPosition[i,2]-1] = -2
screen <- plotLabyrinth(data)
}
else{
nextPosition[length(nextPosition)+1]=currentPosition[i,1]
nextPosition[length(nextPosition)+1]=currentPosition[i,2]-1
nextPosition[length(nextPosition)+1]=currentPosition[i,3]
data[currentPosition[i,1],currentPosition[i,2]-1] = -2
screen <- plotLabyrinth(data)
}
}
if (nrow(currentPosition) > 1 ){
nextPosMx=currentPosition[-i,]
if (length(nextPosition) > 0)
nextPosMx=rbind(nextPosMx,t(matrix(c(nextPosition), nrow=3)))
}else{
if (length(nextPosition) > 0)
nextPosMx=t(matrix(c(nextPosition), nrow=3))
else
return(data)
}
if (!pathFound)
kt=mainA(data,nextPosMx)
if (is.matrix(kt)) data=kt
if (smer == 1 && data[currentPosition[i,1]+1,currentPosition[i,2]] == -5 ||
smer == 2 && data[currentPosition[i,1],currentPosition[i,2]+1] == -5 ||
smer == 3 && data[currentPosition[i,1]-1,currentPosition[i,2]] == -5 ||
smer == 4 && data[currentPosition[i,1],currentPosition[i,2]-1] == -5)
data[currentPosition[i,1],currentPosition[i,2]]=-5
else if(data[currentPosition[i,1]+1,currentPosition[i,2]] == -5 ||
data[currentPosition[i,1],currentPosition[i,2]+1] == -5 ||
data[currentPosition[i,1]-1,currentPosition[i,2]] == -5 ||
data[currentPosition[i,1],currentPosition[i,2]-1] == -5)
data[currentPosition[i,1],currentPosition[i,2]]=-5
screen <- plotLabyrinth(data)
return(data)
}
getPath<- function(data,cp){
pathData=cp
dol=data[cp[1]+1,cp[2]]
desno=data[cp[1],cp[2]+1]
gor=data[cp[1]-1,cp[2]]
levo=data[cp[1],cp[2]-1]
x=c(dol,desno,gor,levo)
if(dol == -5)
cp[1]=cp[1]+1
else if(desno == -5)
cp[2]=cp[2]+1
else if(gor == -5)
cp[1]=cp[1]-1
else if(levo == -5)
cp[2]=cp[2]-1
if (!any(x==-5)){
data[pathData[1],pathData[2]]=-4
if(dol == -3)
cp[1]=cp[1]+1
else if(desno == -3)
cp[2]=cp[2]+1
else if(gor == -3)
cp[1]=cp[1]-1
else if(levo == -3)
cp[2]=cp[2]-1
return(rbind(pathData,cp))
}
data[pathData[1],pathData[2]]=-4
return(rbind(pathData,getPath(data,cp)))
}
getPoints<- function(data,matrix){
points=0
for(i in 1:nrow(matrix)){
points=points+data[matrix[i,1],matrix[i,2]]
}
return(points)
}
Azvezda<- function(data,currPos){
data=mainA( data,matrix( c(currPos,0), ncol=3 ) )
return(getPath(data,currPos))
}
data <- read.table("labyrinth_6.txt", sep=",", header=F)
data <- as.matrix(data)
screen <- plotLabyrinth(data)
a=Azvezda(data,which(data == -2, TRUE))
getPoints(data,a)
getPoints<- function(data,matrix){
points=0
for(i in 3:nrow(matrix)-1){
points=points+data[matrix[i,1],matrix[i,2]]
}
return(points)
}
getPoints(data,a)
source("dfs.R")
source("bfs.R")
source("iddfs.R")
source("aStar.R")
source("izris.R")
source("modifyM.R")
#install.packages("gsubfn")
library("gsubfn")
data <- read.table("labyrinth_11.txt", sep=",", header=F)
data <- as.matrix(data)
#preimenujemo zaradi lažjega branja
data <- rename(data)
#določimo stolpec in vrstico starta
start <- startPosition(data)
#določimo številko štartnega kvadratka
trueStart = toString(nrow(data) * (start[1,1] - 1) + start[1,2])
#ponovimo še za finish
finish <- finishPosition(data)
#le da naredimo vektor, saj je ciljev več
trueFinish = c()
for (var in 1:nrow(finish)) {
trueFinish <- c(trueFinish, toString(nrow(data) * (finish[var,1] - 1) + finish[var,2]))
}
screen <- plotLabyrinth(data)
#naredimo matriko sosedov
sosedje <- matrikaSosedov(data)
#preimenujemo stolpce in vrstice v številke kvadratkov
#colnames(sosedje) <- c(1:nrow(sosedje))
#rownames(sosedje) <- c(1:ncol(sosedje))
sosedje <- rename(sosedje)
data <- read.table("labyrinth_7.txt", sep=",", header=F)
data <- as.matrix(data)
#preimenujemo zaradi lažjega branja
data <- rename(data)
#določimo stolpec in vrstico starta
start <- startPosition(data)
#določimo številko štartnega kvadratka
trueStart = toString(nrow(data) * (start[1,1] - 1) + start[1,2])
#ponovimo še za finish
finish <- finishPosition(data)
#le da naredimo vektor, saj je ciljev več
trueFinish = c()
for (var in 1:nrow(finish)) {
trueFinish <- c(trueFinish, toString(nrow(data) * (finish[var,1] - 1) + finish[var,2]))
}
screen <- plotLabyrinth(data)
#naredimo matriko sosedov
sosedje <- matrikaSosedov(data)
#preimenujemo stolpce in vrstice v številke kvadratkov
#colnames(sosedje) <- c(1:nrow(sosedje))
#rownames(sosedje) <- c(1:ncol(sosedje))
sosedje <- rename(sosedje)
data <- read.table("labyrinth_11.txt", sep=",", header=F)
data <- as.matrix(data)
#preimenujemo zaradi lažjega branja
data <- rename(data)
#določimo stolpec in vrstico starta
start <- startPosition(data)
#določimo številko štartnega kvadratka
trueStart = toString(nrow(data) * (start[1,1] - 1) + start[1,2])
#ponovimo še za finish
finish <- finishPosition(data)
#le da naredimo vektor, saj je ciljev več
trueFinish = c()
for (var in 1:nrow(finish)) {
trueFinish <- c(trueFinish, toString(nrow(data) * (finish[var,1] - 1) + finish[var,2]))
}
screen <- plotLabyrinth(data)
#naredimo matriko sosedov
sosedje <- matrikaSosedov(data)
#preimenujemo stolpce in vrstice v številke kvadratkov
#colnames(sosedje) <- c(1:nrow(sosedje))
#rownames(sosedje) <- c(1:ncol(sosedje))
sosedje <- rename(sosedje)
as <- a.star(sosedje, trueStart, trueFinish)
source("aStar.R")
as <- a.star(sosedje, trueStart, trueFinish)
a <- convertCoord(as, ncol(sosedje))
pathMatrixes(data, a)
###############################################################################
#                               SOURCE                                        #
###############################################################################
source("dfs.R")
source("bfs.R")
source("iddfs.R")
source("aStar.R")
source("izris.R")
source("modifyM.R")
#install.packages("gsubfn")
library("gsubfn")
###############################################################################
#                        PRIPRAVIMO PODATKE                                   #
###############################################################################
data <- read.table("labyrinth_11.txt", sep=",", header=F)
data <- as.matrix(data)
#preimenujemo zaradi lažjega branja
data <- rename(data)
#določimo stolpec in vrstico starta
start <- startPosition(data)
#določimo številko štartnega kvadratka
trueStart = toString(nrow(data) * (start[1,1] - 1) + start[1,2])
#ponovimo še za finish
finish <- finishPosition(data)
#le da naredimo vektor, saj je ciljev več
trueFinish = c()
for (var in 1:nrow(finish)) {
trueFinish <- c(trueFinish, toString(nrow(data) * (finish[var,1] - 1) + finish[var,2]))
}
screen <- plotLabyrinth(data)
#naredimo matriko sosedov
sosedje <- matrikaSosedov(data)
#preimenujemo stolpce in vrstice v številke kvadratkov
#colnames(sosedje) <- c(1:nrow(sosedje))
#rownames(sosedje) <- c(1:ncol(sosedje))
sosedje <- rename(sosedje)
as <- a.star(sosedje, trueStart, trueFinish)
a <- convertCoord(as, ncol(sosedje))
print(paste("Stevilo vozlisc na poti:", nrow(a)))
printPrice(a, data)
pathMatrixes(data, a)
#izpišemo rešitev
setsOfCoords(a)
###############################################################################
#                               SOURCE                                        #
###############################################################################
source("dfs.R")
source("bfs.R")
source("iddfs.R")
source("aStar.R")
source("izris.R")
source("modifyM.R")
#install.packages("gsubfn")
library("gsubfn")
###############################################################################
#                        PRIPRAVIMO PODATKE                                   #
###############################################################################
data <- read.table("labyrinth_11.txt", sep=",", header=F)
data <- as.matrix(data)
#preimenujemo zaradi lažjega branja
data <- rename(data)
#določimo stolpec in vrstico starta
start <- startPosition(data)
#določimo številko štartnega kvadratka
trueStart = toString(nrow(data) * (start[1,1] - 1) + start[1,2])
#ponovimo še za finish
finish <- finishPosition(data)
#le da naredimo vektor, saj je ciljev več
trueFinish = c()
for (var in 1:nrow(finish)) {
trueFinish <- c(trueFinish, toString(nrow(data) * (finish[var,1] - 1) + finish[var,2]))
}
screen <- plotLabyrinth(data)
#naredimo matriko sosedov
sosedje <- matrikaSosedov(data)
#preimenujemo stolpce in vrstice v številke kvadratkov
#colnames(sosedje) <- c(1:nrow(sosedje))
#rownames(sosedje) <- c(1:ncol(sosedje))
sosedje <- rename(sosedje)
list[pot,as] <- a.star(sosedje, trueStart, trueFinish, data)
as
list
pot
###############################################################################
#                               SOURCE                                        #
###############################################################################
source("dfs.R")
source("bfs.R")
source("iddfs.R")
source("aStar.R")
source("izris.R")
source("modifyM.R")
#install.packages("gsubfn")
library("gsubfn")
###############################################################################
#                        PRIPRAVIMO PODATKE                                   #
###############################################################################
data <- read.table("labyrinth_11.txt", sep=",", header=F)
data <- as.matrix(data)
#preimenujemo zaradi lažjega branja
data <- rename(data)
#določimo stolpec in vrstico starta
start <- startPosition(data)
#določimo številko štartnega kvadratka
trueStart = toString(nrow(data) * (start[1,1] - 1) + start[1,2])
#ponovimo še za finish
finish <- finishPosition(data)
#le da naredimo vektor, saj je ciljev več
trueFinish = c()
for (var in 1:nrow(finish)) {
trueFinish <- c(trueFinish, toString(nrow(data) * (finish[var,1] - 1) + finish[var,2]))
}
screen <- plotLabyrinth(data)
#naredimo matriko sosedov
sosedje <- matrikaSosedov(data)
#preimenujemo stolpce in vrstice v številke kvadratkov
#colnames(sosedje) <- c(1:nrow(sosedje))
#rownames(sosedje) <- c(1:ncol(sosedje))
sosedje <- rename(sosedje)
list[pot,as] <- a.star(sosedje, trueStart, trueFinish, data)
source('~/GitHub/Path_algorithms/modifyM.R')
###############################################################################
#                               SOURCE                                        #
###############################################################################
source("dfs.R")
source("bfs.R")
source("iddfs.R")
source("aStar.R")
source("izris.R")
source("modifyM.R")
#install.packages("gsubfn")
library("gsubfn")
###############################################################################
#                        PRIPRAVIMO PODATKE                                   #
###############################################################################
data <- read.table("labyrinth_11.txt", sep=",", header=F)
data <- as.matrix(data)
#preimenujemo zaradi lažjega branja
data <- rename(data)
#določimo stolpec in vrstico starta
start <- startPosition(data)
#določimo številko štartnega kvadratka
trueStart = toString(nrow(data) * (start[1,1] - 1) + start[1,2])
#ponovimo še za finish
finish <- finishPosition(data)
#le da naredimo vektor, saj je ciljev več
trueFinish = c()
for (var in 1:nrow(finish)) {
trueFinish <- c(trueFinish, toString(nrow(data) * (finish[var,1] - 1) + finish[var,2]))
}
screen <- plotLabyrinth(data)
#naredimo matriko sosedov
sosedje <- matrikaSosedov(data)
#preimenujemo stolpce in vrstice v številke kvadratkov
#colnames(sosedje) <- c(1:nrow(sosedje))
#rownames(sosedje) <- c(1:ncol(sosedje))
sosedje <- rename(sosedje)
list[pot,as] <- a.star(sosedje, trueStart, trueFinish, data)
a <- convertCoord(as, ncol(sosedje))
print(paste("Stevilo vozlisc na poti:", nrow(a)))
printPrice(a, data)
pathMatrixes(data, a)
pathMatrixes(pot, a)
#izpišemo rešitev
setsOfCoords(a)
print(paste("Stevilo obravnavanih ogljisc: ", nrow(which(pot == -5, T))))
#naredimo dfs
list[pot,dfs] <- depth.first(sosedje, trueStart, trueFinish, data)
f <- convertCoord(dfs, ncol(sosedje))
print(paste("Stevilo vozlisc na poti:", nrow(f)))
printPrice(f, data)
pathMatrixes(pot, f)
#izpišemo rešitev
setsOfCoords(f)
debugSource('~/GitHub/Path_algorithms/dfs.R', encoding = 'UTF-8')
source("dfs.R")
#naredimo dfs
list[pot,dfs] <- depth.first(sosedje, trueStart, trueFinish, data)
source('~/GitHub/Path_algorithms/modifyM.R')
###############################################################################
#                               SOURCE                                        #
###############################################################################
source("dfs.R")
source("bfs.R")
source("iddfs.R")
source("aStar.R")
source("izris.R")
source("modifyM.R")
#install.packages("gsubfn")
library("gsubfn")
###############################################################################
#                        PRIPRAVIMO PODATKE                                   #
###############################################################################
data <- read.table("labyrinth_11.txt", sep=",", header=F)
data <- as.matrix(data)
#preimenujemo zaradi lažjega branja
data <- rename(data)
#določimo stolpec in vrstico starta
start <- startPosition(data)
#določimo številko štartnega kvadratka
trueStart = toString(nrow(data) * (start[1,1] - 1) + start[1,2])
#ponovimo še za finish
finish <- finishPosition(data)
#le da naredimo vektor, saj je ciljev več
trueFinish = c()
for (var in 1:nrow(finish)) {
trueFinish <- c(trueFinish, toString(nrow(data) * (finish[var,1] - 1) + finish[var,2]))
}
screen <- plotLabyrinth(data)
#naredimo matriko sosedov
sosedje <- matrikaSosedov(data)
#preimenujemo stolpce in vrstice v številke kvadratkov
#colnames(sosedje) <- c(1:nrow(sosedje))
#rownames(sosedje) <- c(1:ncol(sosedje))
sosedje <- rename(sosedje)
#naredimo dfs
list[pot,dfs] <- depth.first(sosedje, trueStart, trueFinish, data)
f <- convertCoord(dfs, ncol(sosedje))
print(paste("Stevilo vozlisc na poti:", nrow(f)))
printPrice(f, data)
pathMatrixes(pot, f)
#izpišemo rešitev
setsOfCoords(f)
#naredimo bfs
list[pot,bfs] <- breadth.first(sosedje, trueStart, trueFinish, data)
g <- convertCoord(bfs, ncol(sosedje))
print(paste("Stevilo vozlisc na poti:", nrow(g)))
printPrice(g, data)
pathMatrixes(pot,g)
#izpišemo rešitev
setsOfCoords(g)
#izvedemo iterativni deep search
list[pot, idfs] <- iter.deep(sosedje, trueStart, trueFinish, data)
i <- convertCoord(idfs, ncol(sosedje))
print(paste("Stevilo obravnavanih ogljisc: ", nrow(which(pot == -5, T))))
print(paste("Stevilo vozlisc na poti:", nrow(i)))
printPrice(i, data)
pathMatrixes(pot,i)
#izpišemo rešitev
setsOfCoords(i)
list[pot,as] <- a.star(sosedje, trueStart, trueFinish, data)
a <- convertCoord(as, ncol(sosedje))
print(paste("Stevilo obravnavanih ogljisc: ", nrow(which(pot == -5, T))))
print(paste("Stevilo vozlisc na poti:", nrow(a)))
printPrice(a, data)
pathMatrixes(pot, a)
#izpišemo rešitev
setsOfCoords(a)

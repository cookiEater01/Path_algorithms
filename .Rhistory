#                               SOURCE                                        #
###############################################################################
source("dfs.R")
source("bfs.R")
source("izris.R")
source("modifyM.R")
#install.packages("gsubfn")
library("gsubfn")
###############################################################################
#                        PRIPRAVIMO PODATKE                                   #
###############################################################################
data <- read.table("labyrinth_2.txt", sep=",", header=F)
data <- as.matrix(data)
#preimenujemo zaradi lažjega branja
data <- rename(data)
#določimo stolpec in vrstico starta
start <- startPosition(data)
#določimo številko štartnega kvadratka
trueStart = toString(nrow(data) * (start[1,1] - 1) + start[1,2])
#ponovimo še za finish
finish <- finishPosition(data)
#le da naredimo vektor, saj je ciljev več
trueFinish = c()
for (var in 1:nrow(finish)) {
trueFinish <- c(trueFinish, toString(nrow(data) * (finish[var,1] - 1) + finish[var,2]))
}
screen <- plotLabyrinth(data)
#naredimo matriko sosedov
sosedje <- matrikaSosedov(data)
#preimenujemo stolpce in vrstice v številke kvadratkov
#colnames(sosedje) <- c(1:nrow(sosedje))
#rownames(sosedje) <- c(1:ncol(sosedje))
sosedje <- rename(sosedje)
###############################################################################
#                                 DFS                                         #
###############################################################################
#naredimo dfs
list[pot,dfs] <- depth.first(sosedje, trueStart, trueFinish, data)
f <- convertCoord(dfs, ncol(sosedje))
pathMatrixes(pot, f)
#izpišemo rešitev
setsOfCoords(f)
#naredimo bfs
list[pot,bfs] <- breadth.first(sosedje, trueStart, trueFinish, data)
g <- convertCoord(bfs, ncol(sosedje))
pathMatrixes(pot,g)
#izpišemo rešitev
setsOfCoords(g)
# #naredimo novo matriko z potjo
# #naredimo novo matriko z potjo
# pathM <- pathMatrix(bfs, ncol(data), nrow(data))
# #naredimo novo matriko z potjo
# pathM <- pathMatrix(bfs, ncol(data), nrow(data))
#
# #naredimo novo matriko z potjo
# pathM <- pathMatrix(bfs, ncol(data), nrow(data))
#
# #zdržimo še podatke splepih poti, starta in finisha
# #naredimo novo matriko z potjo
# pathM <- pathMatrix(bfs, ncol(data), nrow(data))
#
# #zdržimo še podatke splepih poti, starta in finisha
# pathM <- joinMatrixes(data, pathM)
# #naredimo novo matriko z potjo
# pathM <- pathMatrix(bfs, ncol(data), nrow(data))
#
# #zdržimo še podatke splepih poti, starta in finisha
# pathM <- joinMatrixes(data, pathM)
#
source("bfs.R")
#naredimo bfs
list[pot,bfs] <- breadth.first(sosedje, trueStart, trueFinish, data)
source("iddf.R")
source("iddfs.R")
source("dfs.R")
source("bfs.R")
source("iddfs.R")
source("izris.R")
source("modifyM.R")
#install.packages("gsubfn")
library("gsubfn")
data <- read.table("labyrinth_2.txt", sep=",", header=F)
data <- as.matrix(data)
#preimenujemo zaradi lažjega branja
data <- rename(data)
#določimo stolpec in vrstico starta
start <- startPosition(data)
#določimo številko štartnega kvadratka
trueStart = toString(nrow(data) * (start[1,1] - 1) + start[1,2])
#ponovimo še za finish
finish <- finishPosition(data)
#le da naredimo vektor, saj je ciljev več
trueFinish = c()
for (var in 1:nrow(finish)) {
trueFinish <- c(trueFinish, toString(nrow(data) * (finish[var,1] - 1) + finish[var,2]))
}
screen <- plotLabyrinth(data)
#naredimo matriko sosedov
sosedje <- matrikaSosedov(data)
#preimenujemo stolpce in vrstice v številke kvadratkov
#colnames(sosedje) <- c(1:nrow(sosedje))
#rownames(sosedje) <- c(1:ncol(sosedje))
sosedje <- rename(sosedje)
iter.deep(sosedje, trueStart, trueFinish)
#izvedemo iterativni deep search
idfs <- iter.deep(sosedje, trueStart, trueFinish, data)
#izvedemo iterativni deep search
idfs <- iter.deep(sosedje, trueStart, trueFinish)
i <- convertCoord(idfs, ncol(sosedje))
i
idfs
###############################################################################
#                               SOURCE                                        #
###############################################################################
source("dfs.R")
source("bfs.R")
source("iddfs.R")
source("izris.R")
source("modifyM.R")
#install.packages("gsubfn")
library("gsubfn")
###############################################################################
#                        PRIPRAVIMO PODATKE                                   #
###############################################################################
data <- read.table("labyrinth_2.txt", sep=",", header=F)
data <- as.matrix(data)
#preimenujemo zaradi lažjega branja
data <- rename(data)
#določimo stolpec in vrstico starta
start <- startPosition(data)
#določimo številko štartnega kvadratka
trueStart = toString(nrow(data) * (start[1,1] - 1) + start[1,2])
#ponovimo še za finish
finish <- finishPosition(data)
#le da naredimo vektor, saj je ciljev več
trueFinish = c()
for (var in 1:nrow(finish)) {
trueFinish <- c(trueFinish, toString(nrow(data) * (finish[var,1] - 1) + finish[var,2]))
}
screen <- plotLabyrinth(data)
#naredimo matriko sosedov
sosedje <- matrikaSosedov(data)
#preimenujemo stolpce in vrstice v številke kvadratkov
#colnames(sosedje) <- c(1:nrow(sosedje))
#rownames(sosedje) <- c(1:ncol(sosedje))
sosedje <- rename(sosedje)
#izvedemo iterativni deep search
idfs <- iter.deep(sosedje, trueStart, trueFinish)
i <- convertCoord(idfs, ncol(sosedje))
i
debugSource('~/GitHub/Path_algorithms/modifyM.R')
###############################################################################
#                               SOURCE                                        #
###############################################################################
source("dfs.R")
source("bfs.R")
source("iddfs.R")
source("izris.R")
source("modifyM.R")
#install.packages("gsubfn")
library("gsubfn")
###############################################################################
#                        PRIPRAVIMO PODATKE                                   #
###############################################################################
data <- read.table("labyrinth_2.txt", sep=",", header=F)
data <- as.matrix(data)
#preimenujemo zaradi lažjega branja
data <- rename(data)
#določimo stolpec in vrstico starta
start <- startPosition(data)
#določimo številko štartnega kvadratka
trueStart = toString(nrow(data) * (start[1,1] - 1) + start[1,2])
#ponovimo še za finish
finish <- finishPosition(data)
#le da naredimo vektor, saj je ciljev več
trueFinish = c()
for (var in 1:nrow(finish)) {
trueFinish <- c(trueFinish, toString(nrow(data) * (finish[var,1] - 1) + finish[var,2]))
}
screen <- plotLabyrinth(data)
#naredimo matriko sosedov
sosedje <- matrikaSosedov(data)
#preimenujemo stolpce in vrstice v številke kvadratkov
#colnames(sosedje) <- c(1:nrow(sosedje))
#rownames(sosedje) <- c(1:ncol(sosedje))
sosedje <- rename(sosedje)
#izvedemo iterativni deep search
idfs <- iter.deep(sosedje, trueStart, trueFinish)
i <- convertCoord(idfs, ncol(sosedje))
#naredimo dfs
list[pot,dfs] <- depth.first(sosedje, trueStart, trueFinish, data)
dfs
idfs
###############################################################################
#                               SOURCE                                        #
###############################################################################
source("dfs.R")
source("bfs.R")
source("iddfs.R")
source("izris.R")
source("modifyM.R")
#install.packages("gsubfn")
library("gsubfn")
###############################################################################
#                        PRIPRAVIMO PODATKE                                   #
###############################################################################
data <- read.table("labyrinth_2.txt", sep=",", header=F)
data <- as.matrix(data)
#preimenujemo zaradi lažjega branja
data <- rename(data)
#določimo stolpec in vrstico starta
start <- startPosition(data)
#določimo številko štartnega kvadratka
trueStart = toString(nrow(data) * (start[1,1] - 1) + start[1,2])
#ponovimo še za finish
finish <- finishPosition(data)
#le da naredimo vektor, saj je ciljev več
trueFinish = c()
for (var in 1:nrow(finish)) {
trueFinish <- c(trueFinish, toString(nrow(data) * (finish[var,1] - 1) + finish[var,2]))
}
screen <- plotLabyrinth(data)
#naredimo matriko sosedov
sosedje <- matrikaSosedov(data)
#preimenujemo stolpce in vrstice v številke kvadratkov
#colnames(sosedje) <- c(1:nrow(sosedje))
#rownames(sosedje) <- c(1:ncol(sosedje))
sosedje <- rename(sosedje)
#izvedemo iterativni deep search
idfs <- iter.deep(sosedje, trueStart, trueFinish)
i <- convertCoord(idfs, ncol(sosedje))
plotLabyrinth()
i
idfs
###############################################################################
#                               SOURCE                                        #
###############################################################################
source("dfs.R")
source("bfs.R")
source("iddfs.R")
source("izris.R")
source("modifyM.R")
#install.packages("gsubfn")
library("gsubfn")
###############################################################################
#                        PRIPRAVIMO PODATKE                                   #
###############################################################################
data <- read.table("labyrinth_2.txt", sep=",", header=F)
data <- as.matrix(data)
#preimenujemo zaradi lažjega branja
data <- rename(data)
#določimo stolpec in vrstico starta
start <- startPosition(data)
#določimo številko štartnega kvadratka
trueStart = toString(nrow(data) * (start[1,1] - 1) + start[1,2])
#ponovimo še za finish
finish <- finishPosition(data)
#le da naredimo vektor, saj je ciljev več
trueFinish = c()
for (var in 1:nrow(finish)) {
trueFinish <- c(trueFinish, toString(nrow(data) * (finish[var,1] - 1) + finish[var,2]))
}
screen <- plotLabyrinth(data)
#naredimo matriko sosedov
sosedje <- matrikaSosedov(data)
#preimenujemo stolpce in vrstice v številke kvadratkov
#colnames(sosedje) <- c(1:nrow(sosedje))
#rownames(sosedje) <- c(1:ncol(sosedje))
sosedje <- rename(sosedje)
#izvedemo iterativni deep search
idfs <- iter.deep(sosedje, trueStart, trueFinish)
i <- convertCoord(idfs, ncol(sosedje))
i
pathMatrixes(data,i)
###############################################################################
#                               SOURCE                                        #
###############################################################################
source("dfs.R")
source("bfs.R")
source("iddfs.R")
source("izris.R")
source("modifyM.R")
#install.packages("gsubfn")
library("gsubfn")
###############################################################################
#                        PRIPRAVIMO PODATKE                                   #
###############################################################################
data <- read.table("labyrinth_2.txt", sep=",", header=F)
data <- as.matrix(data)
#preimenujemo zaradi lažjega branja
data <- rename(data)
#določimo stolpec in vrstico starta
start <- startPosition(data)
#določimo številko štartnega kvadratka
trueStart = toString(nrow(data) * (start[1,1] - 1) + start[1,2])
#ponovimo še za finish
finish <- finishPosition(data)
#le da naredimo vektor, saj je ciljev več
trueFinish = c()
for (var in 1:nrow(finish)) {
trueFinish <- c(trueFinish, toString(nrow(data) * (finish[var,1] - 1) + finish[var,2]))
}
screen <- plotLabyrinth(data)
#naredimo matriko sosedov
sosedje <- matrikaSosedov(data)
#preimenujemo stolpce in vrstice v številke kvadratkov
#colnames(sosedje) <- c(1:nrow(sosedje))
#rownames(sosedje) <- c(1:ncol(sosedje))
sosedje <- rename(sosedje)
#izvedemo iterativni deep search
list[pot, idfs] <- iter.deep(sosedje, trueStart, trueFinish, data)
###############################################################################
#                               SOURCE                                        #
###############################################################################
source("dfs.R")
source("bfs.R")
source("iddfs.R")
source("izris.R")
source("modifyM.R")
#install.packages("gsubfn")
library("gsubfn")
###############################################################################
#                        PRIPRAVIMO PODATKE                                   #
###############################################################################
data <- read.table("labyrinth_2.txt", sep=",", header=F)
data <- as.matrix(data)
#preimenujemo zaradi lažjega branja
data <- rename(data)
#določimo stolpec in vrstico starta
start <- startPosition(data)
#določimo številko štartnega kvadratka
trueStart = toString(nrow(data) * (start[1,1] - 1) + start[1,2])
#ponovimo še za finish
finish <- finishPosition(data)
#le da naredimo vektor, saj je ciljev več
trueFinish = c()
for (var in 1:nrow(finish)) {
trueFinish <- c(trueFinish, toString(nrow(data) * (finish[var,1] - 1) + finish[var,2]))
}
screen <- plotLabyrinth(data)
#naredimo matriko sosedov
sosedje <- matrikaSosedov(data)
#preimenujemo stolpce in vrstice v številke kvadratkov
#colnames(sosedje) <- c(1:nrow(sosedje))
#rownames(sosedje) <- c(1:ncol(sosedje))
sosedje <- rename(sosedje)
#izvedemo iterativni deep search
list[pot, idfs] <- iter.deep(sosedje, trueStart, trueFinish, data)
###############################################################################
#                               SOURCE                                        #
###############################################################################
source("dfs.R")
source("bfs.R")
source("iddfs.R")
source("izris.R")
source("modifyM.R")
#install.packages("gsubfn")
library("gsubfn")
###############################################################################
#                        PRIPRAVIMO PODATKE                                   #
###############################################################################
data <- read.table("labyrinth_2.txt", sep=",", header=F)
data <- as.matrix(data)
#preimenujemo zaradi lažjega branja
data <- rename(data)
#določimo stolpec in vrstico starta
start <- startPosition(data)
#določimo številko štartnega kvadratka
trueStart = toString(nrow(data) * (start[1,1] - 1) + start[1,2])
#ponovimo še za finish
finish <- finishPosition(data)
#le da naredimo vektor, saj je ciljev več
trueFinish = c()
for (var in 1:nrow(finish)) {
trueFinish <- c(trueFinish, toString(nrow(data) * (finish[var,1] - 1) + finish[var,2]))
}
screen <- plotLabyrinth(data)
#naredimo matriko sosedov
sosedje <- matrikaSosedov(data)
#preimenujemo stolpce in vrstice v številke kvadratkov
#colnames(sosedje) <- c(1:nrow(sosedje))
#rownames(sosedje) <- c(1:ncol(sosedje))
sosedje <- rename(sosedje)
#izvedemo iterativni deep search
list[pot, idfs] <- iter.deep(sosedje, trueStart, trueFinish, data)
###############################################################################
#                               SOURCE                                        #
###############################################################################
source("dfs.R")
source("bfs.R")
source("iddfs.R")
source("izris.R")
source("modifyM.R")
#install.packages("gsubfn")
library("gsubfn")
###############################################################################
#                        PRIPRAVIMO PODATKE                                   #
###############################################################################
data <- read.table("labyrinth_2.txt", sep=",", header=F)
data <- as.matrix(data)
#preimenujemo zaradi lažjega branja
data <- rename(data)
#določimo stolpec in vrstico starta
start <- startPosition(data)
#določimo številko štartnega kvadratka
trueStart = toString(nrow(data) * (start[1,1] - 1) + start[1,2])
#ponovimo še za finish
finish <- finishPosition(data)
#le da naredimo vektor, saj je ciljev več
trueFinish = c()
for (var in 1:nrow(finish)) {
trueFinish <- c(trueFinish, toString(nrow(data) * (finish[var,1] - 1) + finish[var,2]))
}
screen <- plotLabyrinth(data)
#naredimo matriko sosedov
sosedje <- matrikaSosedov(data)
#preimenujemo stolpce in vrstice v številke kvadratkov
#colnames(sosedje) <- c(1:nrow(sosedje))
#rownames(sosedje) <- c(1:ncol(sosedje))
sosedje <- rename(sosedje)
#izvedemo iterativni deep search
list[pot, idfs] <- iter.deep(sosedje, trueStart, trueFinish, data)
source("iddfs.R")
#izvedemo iterativni deep search
list[pot, idfs] <- iter.deep(sosedje, trueStart, trueFinish, data)
#izvedemo iterativni deep search
list[pot, idfs] <- iter.deep(sosedje, trueStart, trueFinish, data)
source("iddfs.R")
#izvedemo iterativni deep search
list[pot, idfs] <- iter.deep(sosedje, trueStart, trueFinish, data)
###############################################################################
#                               SOURCE                                        #
###############################################################################
source("dfs.R")
source("bfs.R")
source("iddfs.R")
source("izris.R")
source("modifyM.R")
#install.packages("gsubfn")
library("gsubfn")
###############################################################################
#                        PRIPRAVIMO PODATKE                                   #
###############################################################################
data <- read.table("labyrinth_2.txt", sep=",", header=F)
data <- as.matrix(data)
#preimenujemo zaradi lažjega branja
data <- rename(data)
#določimo stolpec in vrstico starta
start <- startPosition(data)
#določimo številko štartnega kvadratka
trueStart = toString(nrow(data) * (start[1,1] - 1) + start[1,2])
#ponovimo še za finish
finish <- finishPosition(data)
#le da naredimo vektor, saj je ciljev več
trueFinish = c()
for (var in 1:nrow(finish)) {
trueFinish <- c(trueFinish, toString(nrow(data) * (finish[var,1] - 1) + finish[var,2]))
}
screen <- plotLabyrinth(data)
#naredimo matriko sosedov
sosedje <- matrikaSosedov(data)
#preimenujemo stolpce in vrstice v številke kvadratkov
#colnames(sosedje) <- c(1:nrow(sosedje))
#rownames(sosedje) <- c(1:ncol(sosedje))
sosedje <- rename(sosedje)
#izvedemo iterativni deep search
list[pot, idfs] <- iter.deep(sosedje, trueStart, trueFinish, data)
i <- convertCoord(idfs, ncol(sosedje))
pathMatrixes(pot,i)
###############################################################################
#                               SOURCE                                        #
###############################################################################
source("dfs.R")
source("bfs.R")
source("iddfs.R")
source("izris.R")
source("modifyM.R")
#install.packages("gsubfn")
library("gsubfn")
###############################################################################
#                        PRIPRAVIMO PODATKE                                   #
###############################################################################
data <- read.table("labyrinth_2.txt", sep=",", header=F)
data <- as.matrix(data)
#preimenujemo zaradi lažjega branja
data <- rename(data)
#določimo stolpec in vrstico starta
start <- startPosition(data)
#določimo številko štartnega kvadratka
trueStart = toString(nrow(data) * (start[1,1] - 1) + start[1,2])
#ponovimo še za finish
finish <- finishPosition(data)
#le da naredimo vektor, saj je ciljev več
trueFinish = c()
for (var in 1:nrow(finish)) {
trueFinish <- c(trueFinish, toString(nrow(data) * (finish[var,1] - 1) + finish[var,2]))
}
screen <- plotLabyrinth(data)
#naredimo matriko sosedov
sosedje <- matrikaSosedov(data)
#preimenujemo stolpce in vrstice v številke kvadratkov
#colnames(sosedje) <- c(1:nrow(sosedje))
#rownames(sosedje) <- c(1:ncol(sosedje))
sosedje <- rename(sosedje)
###############################################################################
#                                 IDFS                                        #
###############################################################################
#izvedemo iterativni deep search
list[pot, idfs] <- iter.deep(sosedje, trueStart, trueFinish, data)
i <- convertCoord(idfs, ncol(sosedje))
pathMatrixes(pot,i)
sosedje
